/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include <string.h>

#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)

struct cmdInput {
    char *host;
    clientArg *location;
};

typedef struct cmdInput cmdInput;

// function declarations for processing user input
cmdInput * parseCmdLineInput(int argc, char *argv[]);
void checkIfInputValid(int argc, char *argv[]);
cmdInput * populateRequest(char *argv[]);

// function declarations for processing RPC call
placesRet * findAirportsNearCity(char *host, clientArg *userInput);
CLIENT * connectToClient(char *host);
void checkIfResultIsNull(placesRet *result, CLIENT *clnt);
placesRet * createLocalCopy(placesRet *result);
airportInfo * copyAirportInfo(airportInfo *curr);
void disconnectFromClient(CLIENT *clnt, placesRet *result);

// client main function
int
main (int argc, char *argv[])
{
    cmdInput *request = parseCmdLineInput(argc, argv);
	placesRet *result = findAirportsNearCity(request->host, request->location);

    // print places results
    placesLLNode *curr = (result->placesRet_u).airports;
    while (curr != NULL) {
        printf("Code: %s  ", curr->airport->code);
        printf("Name: %s  ", curr->airport->name);
        printf("Distance: %0.2f\n", curr->airport->distance);
        curr = curr->next;
    }

    // TODO: dealloc linked list

    exit(0);
}

cmdInput *
parseCmdLineInput(int argc, char *argv[]) 
{
    checkIfInputValid(argc, argv);
    cmdInput *request = populateRequest(argv);
    return request;
}

void
checkIfInputValid(int argc, char *argv[]) 
{
	if (argc < 4) {
		printf ("usage: %s places_server_host city state\n", argv[0]);
		exit(1);
	}
}

cmdInput *
populateRequest(char *argv[]) 
{
    cmdInput *request = NEW_STRUCT(cmdInput);
    CPY_STRING(request->host, argv[1]);
    request->location = NEW_STRUCT(clientArg);
    CPY_STRING(request->location->city, argv[2]);
    CPY_STRING(request->location->state, argv[3]);
    return request;
}

placesRet *
findAirportsNearCity(char *host, clientArg *userInput)
{
	CLIENT *clnt = connectToClient(host);
	placesRet *result = airports_near_city_1(userInput, clnt);
    checkIfResultIsNull(result, clnt);
    placesRet *resultCpy = createLocalCopy(result);
    disconnectFromClient(clnt, result);
    return resultCpy;
}

CLIENT *
connectToClient(char *host) 
{
    #ifndef	DEBUG
	CLIENT *clnt = clnt_create(host, PLACES_PROG, PLACES_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}
    #endif	/* DEBUG */
}

void
checkIfResultIsNull(placesRet *result, CLIENT *clnt) 
{
	if (result == (placesRet *) NULL) {
		clnt_perror(clnt, "call failed");
	}
}

placesRet *
createLocalCopy(placesRet *result) 
{
    placesRet *resultCpy = NEW_STRUCT(placesRet);
    resultCpy->err = result->err;
    (resultCpy->placesRet_u).airports = NEW_STRUCT(placesLLNode);
    placesLLNode *curr = (result->placesRet_u).airports;
    placesLLNode *cpy = (resultCpy->placesRet_u).airports;
    for (; curr != NULL; curr = curr->next, cpy = cpy->next) {
        cpy->airport = copyAirportInfo(curr->airport);
        cpy->next = (curr->next == NULL) ? NULL : NEW_STRUCT(placesLLNode);
    }
    return resultCpy;
}

airportInfo *
copyAirportInfo(airportInfo *curr) 
{
    airportInfo *newNode = (airportInfo *)malloc(sizeof(airportInfo));
    CPY_STRING(newNode->code, curr->code);
    CPY_STRING(newNode->name, curr->name);
    newNode->distance = curr->distance;
    return newNode;
}

void
disconnectFromClient(CLIENT *clnt, placesRet *result) 
{
    #ifndef	DEBUG
    clnt_freeres(clnt, (xdrproc_t)xdr_placesRet, result);
	clnt_destroy(clnt);
    #endif	 /* DEBUG */
}
