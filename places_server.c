/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <ctype.h>
#include <stdbool.h>
#include <stdlib.h>

#include "places.h"
#include "airports.h"
#include "./trie/trie.h"

#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)
#define SUBSTR(src, dst, start, end) memcpy(dst, &src[start-1], end-start+1); dst[end-start+1] = '\0'

#define NUM_ENTRIES (25375)

// function declarations
placesLLNode * testLL();

// function declarations for processing RPC call
airportsRet * findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate);
CLIENT * connectToClient(char *host);
void checkIfResultIsNull(airportsRet *result, CLIENT *clnt);
void disconnectFromClient(CLIENT *clnt, airportsRet *result);

void print_paths(const struct trie_node *const node, int pos) {
  static char prefix[256];
  char c = node->letter;
  if (node->down != NULL) {
    prefix[pos] = c;
    printf("%c", c);
    print_paths(node->down, pos + 1);
  }
  else {
    printf("%c\n", c);
  }
  if (node->next != NULL) {
    for (int i = 0; i < pos; i++) {
      printf("%c", prefix[i]);
    }
    print_paths(node->next, pos);
  }
}

void str_lower(char *str) {
    while (*str != '\0') {
        *str = tolower(*str);
        str++;
    }
}

void str_trim_end(char *str, int end, int (*check)(int), bool cond) {
    int i = end;
    while (check(str[i]) == cond) {
        str[i--] = '\0';
    }
}

void read_file(struct location *locs, struct trie *trie) {
    char *placesFile = "data/places2k.txt";
    FILE *fp = fopen(placesFile, "r");
    if (fp == NULL) {
        printf("Could not open file %s\n", placesFile);
        exit(1);
    }
    char line[256], state[3], city[65], latitude[11], longitude[12];
    int i = 0;
    while (fgets(line, sizeof(line), fp) != NULL) {
        SUBSTR(line, state, 1, 2);
        SUBSTR(line, city, 10, 73);
        SUBSTR(line, latitude, 145, 153);
        SUBSTR(line, longitude, 155, 164);
        str_trim_end(state, sizeof(state) - 1, isalpha, false);
        str_trim_end(city, sizeof(city) - 1, isalpha, false);
        str_trim_end(latitude, sizeof(latitude) - 1, isdigit, false);
        str_trim_end(longitude, sizeof(longitude) - 1, isdigit, false);
        str_lower(state);
        str_lower(city);
        str_lower(latitude);
        str_lower(longitude);
        // printf("    State: %s|\n", state);
        // printf("    City: %s|\n", city);
        // printf("    Latitude: %s|\n", latitude);
        // printf("    Longitude: %s|\n", longitude);
        locs[i] = (struct location) {
            .fullName = strdup(city),
            .state = strdup(state),
            .latitude = atof(latitude),
            .longitude = atof(longitude),
        };
        trie_add_entry(trie, city, locs + i);
        i++;
    }
    /*
    for (i = 0; i < NUM_ENTRIES; i++) {
        struct trie_search_result search = trie_search(trie, locs[i].fullName);
        if (*(search.rest) != '\0') {
            printf("FAIL\n");
        }
    }
    */
    fclose(fp);
}

// places server main function
placesRet *
airports_near_city_1_svc(clientArg *argp, struct svc_req *rqstp)
{
    static struct location locs[NUM_ENTRIES];
    static struct trie trie;
	static placesRet result;

    (void)rqstp; // remove compilation warning (what is rqstp?)
    // initialize server function
    // xdr_free((xdrproc_t)xdr_placesRet, &result);
    result.err = 0;
    
    if (trie.root == NULL) {
        read_file(locs, &trie);
    }
    // print_paths((void *)&(trie.root), 0);

    // print payload from client
    printf("clientArg\n");
    printf("city: %s   state: %s\n", argp->city, argp->state);
    
    struct trie_search_result search = trie_search(&trie, argp->city);
    struct location query = search.last->data;

    // test call airports server
    placesArg *coordinate = NEW_STRUCT(placesArg);
    coordinate->latitude = 1.0;
    coordinate->longitude = 0.5;
	CLIENT *clnt = connectToClient("localhost");
    airportsRet *airportsResult = findAirportsNearCoord(clnt, coordinate);

    // print airports result
    airportsLLNode *curr = (airportsResult->airportsRet_u).airports;
    while (curr != NULL) {
        printf("Code: %s  ", curr->airport->code);
        printf("Name: %s  ", curr->airport->name);
        printf("Latitude: %0.2f  ", curr->airport->latitude);
        printf("Longitude: %0.2f\n", curr->airport->longitude);
        curr = curr->next;
    }
    printf("\n\n");

    disconnectFromClient(clnt, airportsResult);

    // return test result
    result.placesRet_u.airports = testLL();
	return &result;
}

placesLLNode *
testLL() 
{
    placesLLNode *LL = NEW_STRUCT(placesLLNode);
    placesLLNode *curr = LL;
    for (int i = 0; i < 5; i++) {
        airportInfo *newNode = NEW_STRUCT(airportInfo);
        newNode->code = "code";
        newNode->name = "name";
        newNode->distance = 3.14;
        curr->airport = newNode;
        curr->next = (i == 4) ? NULL : NEW_STRUCT(placesLLNode);
        curr = curr->next;
    }
    return LL;
}

airportsRet *
findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate)
{
	airportsRet *result = airports_near_coord_1(coordinate, clnt);
    checkIfResultIsNull(result, clnt);
    return result;
}

CLIENT *
connectToClient(char *host) 
{
    #ifndef	DEBUG
	CLIENT *clnt = clnt_create(host, AIRPORTS_PROG, AIRPORTS_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}
    #endif	/* DEBUG */
}

void
checkIfResultIsNull(airportsRet *result, CLIENT *clnt) 
{
	if (result == (airportsRet *) NULL) {
		clnt_perror(clnt, "call failed");
	}
}

void
disconnectFromClient(CLIENT *clnt, airportsRet *result) 
{
    #ifndef	DEBUG
    clnt_freeres(clnt, (xdrproc_t)xdr_airportsRet, result);
	clnt_destroy(clnt);
    #endif	 /* DEBUG */
}
