/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <ctype.h>

#include "places.h"
#include "airports.h"
#include "./trie/trie.h"

#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)
#define SUBSTR(src, dst, start, end) memcpy(dst, &src[start-1], end-start+1); dst[end-start+1] = '\0'

// function declarations
placesLLNode * testLL();

// function declarations for processing RPC call
airportsRet * findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate);
CLIENT * connectToClient(char *host);
void checkIfResultIsNull(airportsRet *result, CLIENT *clnt);
void disconnectFromClient(CLIENT *clnt, airportsRet *result);

void print_paths(const struct trie_node *const node, int pos) {
  static char prefix[256];
  char c = node->letter;
  if (node->down != NULL) {
    prefix[pos] = c;
    printf("%c", c);
    print_paths(node->down, pos + 1);
  }
  else {
    printf("%c\n", c);
  }
  if (node->next != NULL) {
    for (int i = 0; i < pos; i++) {
      printf("%c", prefix[i]);
    }
    print_paths(node->next, pos);
  }
}


#define NUM_ENTRIES (25375)
// places server main function
placesRet *
airports_near_city_1_svc(clientArg *argp, struct svc_req *rqstp)
{
    static char **strarr;
    static struct trie trie;
	static placesRet result;

    // initialize server function
    // xdr_free((xdrproc_t)xdr_placesRet, &result);
    result.err = 0;
    
    if (strarr == NULL) {
        char *placesFile = "data/places2k.txt";
        FILE *fp = fopen(placesFile, "r");
        if (fp == NULL) {
            printf("Could not open file %s\n", placesFile);
            exit(1);
        }
        strarr = malloc((sizeof *strarr) * NUM_ENTRIES);
        trie = (struct trie){ .root = NULL };
        char line[256], state[3], city[65], latitude[11], longitude[12];
        int i = 0;
        while (fgets(line, sizeof(line), fp) != NULL) {
            SUBSTR(line, state, 1, 2);
            SUBSTR(line, city, 10, 73);
            /*
            int j = sizeof(city) - 1;
            while (!isalpha(city[j])) {
                city[j--] = '\0';
            }
            */
            SUBSTR(line, latitude, 144, 153);
            SUBSTR(line, longitude, 154, 164);
            // printf("    State: %s\n", state);
            // printf("    City: %s|\n", city);
            // printf("    Latitude: %s\n", latitude);
            // printf("    Longitude: %s\n", longitude);
            strarr[i++] = strdup(city);
            trie_add_entry(&trie, city, NULL);
        }
        for (i = 0; i < NUM_ENTRIES; i++) {
            struct trie_search_result search = trie_search(&trie, strarr[i]);
            if (*(search.rest) != '\0') {
                printf("FAIL: %s\n");
            }
        }
    }

    /*
    // demonstrates that all (or at least a lot of..) entries are successfully added to trie
    print_paths(trie.root, 0);
    
    // demonstration of how to search the trie
    struct trie_search_result search = trie_search(&trie, "Longview city");
    if (*(search.rest) == '\0') {
        printf("Longview city found\n");
    } else {
        printf("Longview city not found\n");
    }
    search = trie_search(&trie, "Afton city");
    if (*(search.rest) == '\0') {
        printf("Afton city found\n");
    } else {
        printf("Afton City not found\n");
    }
    // close file
    fclose(fp);
    */

    // print payload from client
    printf("clientArg\n");
    printf("city: %s   state: %s\n", argp->city, argp->state);

    // test call airports server
    placesArg *coordinate = NEW_STRUCT(placesArg);
    coordinate->latitude = 6.28;
    coordinate->longitude = 0.5;
	CLIENT *clnt = connectToClient("localhost");
    airportsRet *airportsResult = findAirportsNearCoord(clnt, coordinate);

    // print airports result
    airportsLLNode *curr = (airportsResult->airportsRet_u).airports;
    while (curr != NULL) {
        printf("Code: %s  ", curr->airport->code);
        printf("Name: %s  ", curr->airport->name);
        printf("Latitude: %0.2f  ", curr->airport->latitude);
        printf("Longitude: %0.2f\n", curr->airport->longitude);
        curr = curr->next;
    }
    printf("\n\n");

    disconnectFromClient(clnt, airportsResult);

    // return test result
    result.placesRet_u.results.airports = testLL();
	return &result;
}

placesLLNode *
testLL() 
{
    placesLLNode *LL = NEW_STRUCT(placesLLNode);
    placesLLNode *curr = LL;
    for (int i = 0; i < 5; i++) {
        airportInfo *newNode = NEW_STRUCT(airportInfo);
        newNode->code = "code";
        newNode->name = "name";
        newNode->distance = 3.14;
        curr->airport = newNode;
        curr->next = (i == 4) ? NULL : NEW_STRUCT(placesLLNode);
        curr = curr->next;
    }
    return LL;
}

airportsRet *
findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate)
{
	airportsRet *result = airports_near_coord_1(coordinate, clnt);
    checkIfResultIsNull(result, clnt);
    return result;
}

CLIENT *
connectToClient(char *host) 
{
    #ifndef	DEBUG
	CLIENT *clnt = clnt_create(host, AIRPORTS_PROG, AIRPORTS_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}
    #endif	/* DEBUG */
}

void
checkIfResultIsNull(airportsRet *result, CLIENT *clnt) 
{
	if (result == (airportsRet *) NULL) {
		clnt_perror(clnt, "call failed");
	}
}

void
disconnectFromClient(CLIENT *clnt, airportsRet *result) 
{
    #ifndef	DEBUG
    clnt_freeres(clnt, (xdrproc_t)xdr_airportsRet, result);
	clnt_destroy(clnt);
    #endif	 /* DEBUG */
}
