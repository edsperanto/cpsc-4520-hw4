/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "airports.h"
#include "./kdtree/kdtree.h"

#define K 5
#define LINE_SIZE 64
#define NUM_ENTRIES 1072
#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)
#define IS_SPACE(ch) (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
#define IS_ENDING(ch) (ch == '\n' || ch == '\r' || ch == '\0')

int isEmpty(const char *str);
void generateAirport(char *line, airport *newAirport);
void readAirportColumn(int col, char *line, char *cpy);
int skipToStartOfColumn(int col, char *line);

airportsRet *
airports_near_coord_1_svc(placesArg *argp, struct svc_req *rqstp)
{
    static airport *airports = NULL;
    static kdTree *kd = NULL;
	static airportsRet result;
    
    // initialize server function
    xdr_free((xdrproc_t)xdr_airportsRet, &result);
    result.err = 0;

    // generate k-d tree from airports file
    if (airports == NULL) {

        // load file
        char *airportsFile = "data/airport-locations.txt";
        FILE *fp = fopen(airportsFile, "r");
        if (fp == NULL) {
            printf("Could not open file %s\n", airportsFile);
            exit(1);
        }

        // read file
        char line[LINE_SIZE];
        airports = (airport *)malloc(sizeof(airport)*NUM_ENTRIES);
        fgets(line, sizeof(line), fp); // ignore first line
        for (int i = 0; fgets(line, sizeof(line), fp) != NULL; ) {
            if (!isEmpty(line)) {
                generateAirport(line, airports + i);
                i++;
            }
        }

        // close file and generate kd tree
        fclose(fp);
        kd = generateKdTree(airports, NUM_ENTRIES);

    }

    // find k nearest neighbors
    kdNode *nearest[K];
    kNearestNeighbor(kd->root, K, argp->latitude, argp->longitude, nearest);

    // return results
    airport *ap_out = result.airportsRet_u.result.airports;
    for (int i = 0; i < K; i++) {
        airport *ap_in = nearest[i]->airport;
        ap_out[i] = (airport) {
            .latitude = ap_in->latitude,
            .longitude = ap_in->longitude,
            .distance = ap_in->distance,
        };
        for (int j = 0; j < 4; j++) {
            ap_out[i].code[j] = ap_in->code[j];
        }
        for (int j = 0; j < 50; j++) {
            ap_out[i].name[j] = ap_in->name[j];
        }
    }
	return &result;
}

int
isEmpty(const char *str)
{
    char ch;
    for (ch = *str; IS_SPACE(ch); ch = *(str++)) ;
    return ch == '\0';
}

void
generateAirport(char *line, airport *newAirport)
{
    char code[4], lat[8], lon[8], city[50];
    readAirportColumn(1, line, code);
    readAirportColumn(2, line, lat);
    readAirportColumn(3, line, lon);
    readAirportColumn(4, line, city);
    for (int i = 0; i < 4; i++) {
        newAirport->code[i] = code[i];
    }
    for (int i = 0; i < 50; i++) {
        newAirport->name[i] = city[i];
    }
    newAirport->latitude = atof(lat);
    newAirport->longitude = atof(lon);
    newAirport->distance = 0;
}

void
readAirportColumn(int col, char *line, char *cpy)
{
    int i = 0, j = skipToStartOfColumn(col, line);
    switch (col) {
        case 1: for (j = 1; j < 4; i++, j++) cpy[i] = line[j]; break;
        case 2: case 3: while (!IS_SPACE(line[j])) cpy[i++] = line[j++]; break;
        case 4: while (!IS_ENDING(line[j])) cpy[i++] = line[j++]; break;
    }
    cpy[i] = '\0';
}

int
skipToStartOfColumn(int col, char *line)
{
    int j = 0, inCol = 1;
    for (int s = 1; s < col; j++) {
        if (inCol && IS_SPACE(line[j])) {
            inCol = 0;
        }
        if (!inCol && !IS_SPACE(line[j+1])) {
            inCol = 1;
            s++;
        }
    }
    return j;
}
