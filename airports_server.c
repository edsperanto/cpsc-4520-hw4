/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "airports.h"
#include "./kdtree/kdtree.h"

#define LINE_SIZE 64
#define NUM_ENTRIES 1072
#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)
#define IS_SPACE(ch) (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
#define IS_ENDING(ch) (ch == '\n' || ch == '\r' || ch == '\0')

airportsLLNode * testLL();

int isEmpty(const char *str);
void generateAirport(char *line, airport *newAirport);
void readAirportColumn(int col, char *line, char *cpy);
int skipToStartOfColumn(int col, char *line);

airportsRet *
airports_near_coord_1_svc(placesArg *argp, struct svc_req *rqstp)
{
    static airport *airports = NULL;
    static kdTree *kd = NULL;
	static airportsRet result;

    // initialize server function
    // xdr_free((xdrproc_t)xdr_airportsRet, &result);
    result.err = 0;
    result.airportsRet_u.airports = NULL;

    // generate k-d tree from airports file
    if (airports == NULL) {

        // load file
        char *airportsFile = "data/airport-locations.txt";
        FILE *fp = fopen(airportsFile, "r");
        if (fp == NULL) {
            printf("Could not open file %s\n", airportsFile);
            exit(1);
        }

        // read file
        char line[LINE_SIZE];
        airports = (airport *)malloc(sizeof(airport)*NUM_ENTRIES);
        fgets(line, sizeof(line), fp); // ignore first line
        for (int i = 0; fgets(line, sizeof(line), fp) != NULL; ) {
            if (!isEmpty(line)) {
                generateAirport(line, airports+i++);
            }
        }

        // close file and generate kd tree
        fclose(fp);
        kd = generateKdTree(airports, NUM_ENTRIES);

    }

    // check if airports loaded in k-d tree
    // check if search works
    kdNode *nearest = NULL;
    double *nearest_dist;
    nearestNeighbor(kd->root, argp->latitude, argp->longitude, &nearest, nearest_dist);

    // return test payload
    result.airportsRet_u.airports = testLL();
	return &result;
}

airportsLLNode *
testLL() 
{
    airportsLLNode *LL = (airportsLLNode *)malloc(sizeof(airportsLLNode));
    airportsLLNode *curr = LL;
    for (int i = 0; i < 5; i++) {
        airport *newNode = (airport *)malloc(sizeof(airport));
        newNode->code = "code";
        newNode->name = "name";
        newNode->latitude = 3.14;
        newNode->longitude = 2.718;
        curr->airport = newNode;
        curr->next = (i == 4) ? NULL : (airportsLLNode *)malloc(sizeof(airportsLLNode));
        curr = curr->next;
    }
    return LL;
}

int
isEmpty(const char *str)
{
    char ch;
    for (ch = *str; IS_SPACE(ch); ch = *(str++)) ;
    return ch == '\0';
}

void
generateAirport(char *line, airport *newAirport)
{
    char code[4], lat[8], lon[8], city[50];
    readAirportColumn(1, line, code);
    readAirportColumn(2, line, lat);
    readAirportColumn(3, line, lon);
    readAirportColumn(4, line, city);
    CPY_STRING(newAirport->code, code);
    CPY_STRING(newAirport->name, city);
    newAirport->latitude = atof(lat);
    newAirport->longitude = atof(lon);
    newAirport->distance = 0;
}

void
readAirportColumn(int col, char *line, char *cpy)
{
    int i = 0, j = skipToStartOfColumn(col, line);
    switch (col) {
        case 1: for (j = 1; j < 4; i++, j++) cpy[i] = line[j]; break;
        case 2: case 3: while (!IS_SPACE(line[j])) cpy[i++] = line[j++]; break;
        case 4: while (!IS_ENDING(line[j])) cpy[i++] = line[j++]; break;
    }
    cpy[i] = '\0';
}

int
skipToStartOfColumn(int col, char *line)
{
    int j = 0, inCol = 1;
    for (int s = 1; s < col; j++) {
        if (inCol && IS_SPACE(line[j])) {
            inCol = 0;
        }
        if (!inCol && !IS_SPACE(line[j+1])) {
            inCol = 1;
            s++;
        }
    }
    return j;
}
